// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Efloud Price Action Trading System v3.1 - BALANCED STRATEGY
// More trades while maintaining quality - optimized defaults

//@version=6
strategy("EPA Strategy v3.1", shorttitle="EPA-v3.1", overlay=true,
         default_qty_type=strategy.percent_of_equity, default_qty_value=5,
         initial_capital=10000, commission_type=strategy.commission.percent,
         commission_value=0.1, slippage=2, pyramiding=0, calc_on_every_tick=false)

// ═══════════════════════════════════════════════════════════════════════════
//                              STRATEGY INPUTS
// ═══════════════════════════════════════════════════════════════════════════

grpStrategy = "═══ Risk Management ═══"
riskPercent = input.float(1.5, "Risk Per Trade (%)", minval=0.5, maxval=5.0, step=0.5, group=grpStrategy, tooltip="Percentage of equity to risk per trade")
stopLossATR = input.float(1.5, "Stop Loss (ATR x)", minval=1.0, maxval=5.0, step=0.5, group=grpStrategy)
takeProfitRR = input.float(2.0, "Take Profit (R:R)", minval=1.0, maxval=5.0, step=0.5, group=grpStrategy, tooltip="Risk to Reward ratio")
useTrailingStop = input.bool(true, "Use Trailing Stop", group=grpStrategy)
trailActivation = input.float(1.0, "Trail Activation (R)", minval=0.5, maxval=3.0, step=0.5, group=grpStrategy, tooltip="Activate trailing after X times risk")
trailOffset = input.float(0.75, "Trail Offset (ATR x)", minval=0.5, maxval=3.0, step=0.25, group=grpStrategy)

grpFilters = "═══ Entry Filters ═══"
useHTFFilter = input.bool(true, "HTF Trend Filter", group=grpFilters)
htfTimeframe = input.timeframe("D", "HTF Timeframe", group=grpFilters)
useHTF2Filter = input.bool(false, "HTF2 Structure Filter", group=grpFilters)
htf2Timeframe = input.timeframe("240", "HTF2 Timeframe", group=grpFilters)
useRSIFilter = input.bool(true, "RSI Filter", group=grpFilters)
rsiOverbought = input.int(70, "RSI Overbought", minval=60, maxval=85, group=grpFilters)
rsiOversold = input.int(30, "RSI Oversold", minval=15, maxval=40, group=grpFilters)
useVolatilityFilter = input.bool(false, "Volatility Filter", group=grpFilters)
minATRMultiple = input.float(0.3, "Min ATR Multiple", minval=0.1, maxval=2.0, step=0.1, group=grpFilters)
maxATRMultiple = input.float(4.0, "Max ATR Multiple", minval=1.5, maxval=6.0, step=0.5, group=grpFilters)

grpConfluence = "═══ Confluence Requirements ═══"
minConfluence = input.int(1, "Min Confluence Score", minval=1, maxval=5, group=grpConfluence, tooltip="Minimum signals needed to enter")
useZoneConfirmation = input.bool(false, "Require Zone Entry", group=grpConfluence)
useSFP = input.bool(true, "Use SFP Signals", group=grpConfluence)
useBreaker = input.bool(true, "Use Breaker Signals", group=grpConfluence)
useMitigation = input.bool(true, "Use Mitigation Signals", group=grpConfluence)
useEQLevel = input.bool(true, "Use EQ Level Bounce", group=grpConfluence)

grpTiming = "═══ Trade Timing ═══"
minBarsBetweenTrades = input.int(3, "Min Bars Between Trades", minval=1, maxval=50, group=grpTiming)
maxDailyTrades = input.int(5, "Max Daily Trades", minval=1, maxval=10, group=grpTiming)
useSessionFilter = input.bool(false, "Use Session Filter", group=grpTiming)
sessionStart = input.int(8, "Session Start (UTC)", minval=0, maxval=23, group=grpTiming)
sessionEnd = input.int(20, "Session End (UTC)", minval=0, maxval=23, group=grpTiming)

grpStructure = "═══ Structure Settings ═══"
pivotLookback = input.int(10, "Pivot Lookback", minval=5, maxval=50, group=grpStructure)
pivotLookforward = input.int(10, "Pivot Lookforward", minval=5, maxval=50, group=grpStructure)
sfpWickRatio = input.float(1.5, "SFP Wick Ratio", minval=1.0, maxval=5.0, step=0.5, group=grpStructure)

// ═══════════════════════════════════════════════════════════════════════════
//                              CALCULATIONS
// ═══════════════════════════════════════════════════════════════════════════

// Basic
atr = ta.atr(14)
atrSMA = ta.sma(atr, 50)
volatilityRatio = atr / atrSMA
bodySize = math.abs(close - open)
upperWick = high - math.max(close, open)
lowerWick = math.min(close, open) - low
isBullish = close > open
isBearish = close < open

// Pivots
pivotHigh = ta.pivothigh(high, pivotLookback, pivotLookforward)
pivotLow = ta.pivotlow(low, pivotLookback, pivotLookforward)

// Range Structure
var float rangeHigh = na
var float rangeLow = na
var float equilibrium = na

if not na(pivotHigh)
    rangeHigh := pivotHigh
if not na(pivotLow)
    rangeLow := pivotLow
if not na(rangeHigh) and not na(rangeLow)
    equilibrium := (rangeHigh + rangeLow) / 2

// ═══════════════════════════════════════════════════════════════════════════
//                              HTF FILTERS
// ═══════════════════════════════════════════════════════════════════════════

// HTF1 - Daily trend
[htf1Close, htf1EMA50, htf1EMA200] = request.security(syminfo.tickerid, htfTimeframe, [close, ta.ema(close, 50), ta.ema(close, 200)], lookahead=barmerge.lookahead_off)
htf1Bullish = htf1Close > htf1EMA50 and htf1EMA50 > htf1EMA200
htf1Bearish = htf1Close < htf1EMA50 and htf1EMA50 < htf1EMA200
htf1Neutral = not htf1Bullish and not htf1Bearish

// HTF2 - 4H structure
[htf2Close, htf2EMA20, htf2High, htf2Low] = request.security(syminfo.tickerid, htf2Timeframe, [close, ta.ema(close, 20), ta.highest(high, 20), ta.lowest(low, 20)], lookahead=barmerge.lookahead_off)
htf2Bullish = htf2Close > htf2EMA20 and htf2Close > (htf2High + htf2Low) / 2
htf2Bearish = htf2Close < htf2EMA20 and htf2Close < (htf2High + htf2Low) / 2

// RSI Filter
rsi = ta.rsi(close, 14)
htfRSI = request.security(syminfo.tickerid, htfTimeframe, ta.rsi(close, 14), lookahead=barmerge.lookahead_off)
rsiAllowLong = not useRSIFilter or (rsi < rsiOverbought and htfRSI < rsiOverbought)
rsiAllowShort = not useRSIFilter or (rsi > rsiOversold and htfRSI > rsiOversold)

// Volatility Filter
volatilityOK = not useVolatilityFilter or (volatilityRatio >= minATRMultiple and volatilityRatio <= maxATRMultiple)

// Session Filter
currentHour = hour(time, "UTC")
inSession = not useSessionFilter or (currentHour >= sessionStart and currentHour < sessionEnd)

// ═══════════════════════════════════════════════════════════════════════════
//                           SUPPLY/DEMAND ZONES
// ═══════════════════════════════════════════════════════════════════════════

var box[] demandBoxes = array.new_box()
var float[] demandTops = array.new_float()
var float[] demandBottoms = array.new_float()
var int[] demandBars = array.new_int()
var int[] demandStrength = array.new_int()

var box[] supplyBoxes = array.new_box()
var float[] supplyTops = array.new_float()
var float[] supplyBottoms = array.new_float()
var int[] supplyBars = array.new_int()
var int[] supplyStrength = array.new_int()

// Strong demand zone: bullish engulfing or strong bullish bar after bearish move
strongDemand = isBullish and bodySize > atr * 1.0 and close > high[1] and close[1] < open[1] and close[2] < open[2]
// Strong supply zone: bearish engulfing or strong bearish bar after bullish move
strongSupply = isBearish and bodySize > atr * 1.0 and close < low[1] and close[1] > open[1] and close[2] > open[2]

if strongDemand
    zoneTop = math.max(high[1], open[1])
    zoneBottom = low[1]
    strength = bodySize > atr * 1.5 ? 2 : 1
    newBox = box.new(bar_index - 1, zoneTop, bar_index + 100, zoneBottom, bgcolor=color.new(color.green, 90), border_color=color.new(color.green, 60), border_width=1)
    array.push(demandBoxes, newBox)
    array.push(demandTops, zoneTop)
    array.push(demandBottoms, zoneBottom)
    array.push(demandBars, bar_index)
    array.push(demandStrength, strength)

if strongSupply
    zoneTop = high[1]
    zoneBottom = math.min(low[1], open[1])
    strength = bodySize > atr * 1.5 ? 2 : 1
    newBox = box.new(bar_index - 1, zoneTop, bar_index + 100, zoneBottom, bgcolor=color.new(color.red, 90), border_color=color.new(color.red, 60), border_width=1)
    array.push(supplyBoxes, newBox)
    array.push(supplyTops, zoneTop)
    array.push(supplyBottoms, zoneBottom)
    array.push(supplyBars, bar_index)
    array.push(supplyStrength, strength)

// Zone cleanup
if array.size(demandBoxes) > 0
    for i = array.size(demandBoxes) - 1 to 0
        if i < array.size(demandBottoms)
            if close < array.get(demandBottoms, i) * 0.99 or bar_index - array.get(demandBars, i) > 200
                box.delete(array.get(demandBoxes, i))
                array.remove(demandBoxes, i)
                array.remove(demandTops, i)
                array.remove(demandBottoms, i)
                array.remove(demandBars, i)
                array.remove(demandStrength, i)

if array.size(supplyBoxes) > 0
    for i = array.size(supplyBoxes) - 1 to 0
        if i < array.size(supplyTops)
            if close > array.get(supplyTops, i) * 1.01 or bar_index - array.get(supplyBars, i) > 200
                box.delete(array.get(supplyBoxes, i))
                array.remove(supplyBoxes, i)
                array.remove(supplyTops, i)
                array.remove(supplyBottoms, i)
                array.remove(supplyBars, i)
                array.remove(supplyStrength, i)

// Limit arrays
if array.size(demandBoxes) > 8
    box.delete(array.get(demandBoxes, 0))
    array.shift(demandBoxes)
    array.shift(demandTops)
    array.shift(demandBottoms)
    array.shift(demandBars)
    array.shift(demandStrength)

if array.size(supplyBoxes) > 8
    box.delete(array.get(supplyBoxes, 0))
    array.shift(supplyBoxes)
    array.shift(supplyTops)
    array.shift(supplyBottoms)
    array.shift(supplyBars)
    array.shift(supplyStrength)

// Check zone entry
inDemandZone = false
demandZoneStrength = 0
demandZoneBottom = 0.0
if array.size(demandBoxes) > 0
    for i = 0 to array.size(demandBoxes) - 1
        if i < array.size(demandTops) and i < array.size(demandBottoms)
            if low <= array.get(demandTops, i) and high >= array.get(demandBottoms, i)
                inDemandZone := true
                demandZoneBottom := array.get(demandBottoms, i)
                demandZoneStrength := array.get(demandStrength, i)

inSupplyZone = false
supplyZoneStrength = 0
supplyZoneTop = 0.0
if array.size(supplyBoxes) > 0
    for i = 0 to array.size(supplyBoxes) - 1
        if i < array.size(supplyTops) and i < array.size(supplyBottoms)
            if high >= array.get(supplyBottoms, i) and low <= array.get(supplyTops, i)
                inSupplyZone := true
                supplyZoneTop := array.get(supplyTops, i)
                supplyZoneStrength := array.get(supplyStrength, i)

// ═══════════════════════════════════════════════════════════════════════════
//                           SIGNAL DETECTION
// ═══════════════════════════════════════════════════════════════════════════

// SFP Detection (more strict)
recentSwingHigh = ta.highest(high, 30)[1]
recentSwingLow = ta.lowest(low, 30)[1]

bullishSFP = useSFP and low < recentSwingLow and close > recentSwingLow and close > open and lowerWick > bodySize * sfpWickRatio and bodySize > atr * 0.3
bearishSFP = useSFP and high > recentSwingHigh and close < recentSwingHigh and close < open and upperWick > bodySize * sfpWickRatio and bodySize > atr * 0.3

// Breaker Detection
var float[] obHighs = array.new_float()
var float[] obLows = array.new_float()
var int[] obBars = array.new_int()
var bool[] obBullish = array.new_bool()

strongBullishOB = isBullish and bodySize > atr * 1.2 and close > high[1] and volume > ta.sma(volume, 20)
strongBearishOB = isBearish and bodySize > atr * 1.2 and close < low[1] and volume > ta.sma(volume, 20)

if useBreaker and strongBullishOB
    array.push(obHighs, high)
    array.push(obLows, low[1])
    array.push(obBars, bar_index)
    array.push(obBullish, true)

if useBreaker and strongBearishOB
    array.push(obHighs, high[1])
    array.push(obLows, low)
    array.push(obBars, bar_index)
    array.push(obBullish, false)

bullishBreaker = false
bearishBreaker = false

if useBreaker and array.size(obHighs) > 0
    for i = array.size(obHighs) - 1 to 0
        if i < array.size(obHighs)
            obHigh = array.get(obHighs, i)
            obLow = array.get(obLows, i)
            obBar = array.get(obBars, i)
            wasBullish = array.get(obBullish, i)

            if wasBullish and close[1] < obLow and high >= obLow and high <= obHigh
                bearishBreaker := true
                array.remove(obHighs, i)
                array.remove(obLows, i)
                array.remove(obBars, i)
                array.remove(obBullish, i)
            else if not wasBullish and close[1] > obHigh and low <= obHigh and low >= obLow
                bullishBreaker := true
                array.remove(obHighs, i)
                array.remove(obLows, i)
                array.remove(obBars, i)
                array.remove(obBullish, i)
            else if bar_index - obBar > 100
                array.remove(obHighs, i)
                array.remove(obLows, i)
                array.remove(obBars, i)
                array.remove(obBullish, i)

if array.size(obHighs) > 15
    array.shift(obHighs)
    array.shift(obLows)
    array.shift(obBars)
    array.shift(obBullish)

// Mitigation Detection
var float lastSwingH = na
var float lastSwingL = na

if not na(pivotHigh)
    lastSwingH := pivotHigh
if not na(pivotLow)
    lastSwingL := pivotLow

bullishMitigation = useMitigation and not na(lastSwingL) and low[2] < lastSwingL and close[2] > lastSwingL and close[1] > close[2] and close > close[1] and isBullish
bearishMitigation = useMitigation and not na(lastSwingH) and high[2] > lastSwingH and close[2] < lastSwingH and close[1] < close[2] and close < close[1] and isBearish

// EQ Level Bounce
eqBounce = useEQLevel and not na(equilibrium)
bullishEQBounce = eqBounce and low <= equilibrium * 1.005 and low >= equilibrium * 0.995 and close > equilibrium and isBullish
bearishEQBounce = eqBounce and high >= equilibrium * 0.995 and high <= equilibrium * 1.005 and close < equilibrium and isBearish

// ═══════════════════════════════════════════════════════════════════════════
//                           CONFLUENCE SCORING
// ═══════════════════════════════════════════════════════════════════════════

// Long confluence
longConfluence = 0
longConfluence += bullishSFP ? 2 : 0
longConfluence += bullishBreaker ? 2 : 0
longConfluence += bullishMitigation ? 1 : 0
longConfluence += bullishEQBounce ? 1 : 0
longConfluence += inDemandZone ? demandZoneStrength : 0
longConfluence += htf1Bullish ? 1 : 0
longConfluence += htf2Bullish ? 1 : 0

// Short confluence
shortConfluence = 0
shortConfluence += bearishSFP ? 2 : 0
shortConfluence += bearishBreaker ? 2 : 0
shortConfluence += bearishMitigation ? 1 : 0
shortConfluence += bearishEQBounce ? 1 : 0
shortConfluence += inSupplyZone ? supplyZoneStrength : 0
shortConfluence += htf1Bearish ? 1 : 0
shortConfluence += htf2Bearish ? 1 : 0

// ═══════════════════════════════════════════════════════════════════════════
//                           ENTRY CONDITIONS
// ═══════════════════════════════════════════════════════════════════════════

var int lastTradeBar = -1000
var int dailyTrades = 0
var int lastTradeDay = 0

// Reset daily trade counter
currentDay = dayofweek(time)
if currentDay != lastTradeDay
    dailyTrades := 0
    lastTradeDay := currentDay

canTrade = bar_index - lastTradeBar >= minBarsBetweenTrades and dailyTrades < maxDailyTrades and inSession and volatilityOK

// HTF alignment
htfLongOK = not useHTFFilter or htf1Bullish or htf1Neutral
htfShortOK = not useHTFFilter or htf1Bearish or htf1Neutral
htf2LongOK = not useHTF2Filter or htf2Bullish
htf2ShortOK = not useHTF2Filter or htf2Bearish

// Zone requirement
zoneLongOK = not useZoneConfirmation or inDemandZone
zoneShortOK = not useZoneConfirmation or inSupplyZone

// Final conditions
longCondition = canTrade and longConfluence >= minConfluence and htfLongOK and htf2LongOK and zoneLongOK and rsiAllowLong
shortCondition = canTrade and shortConfluence >= minConfluence and htfShortOK and htf2ShortOK and zoneShortOK and rsiAllowShort

// ═══════════════════════════════════════════════════════════════════════════
//                           POSITION SIZING & EXECUTION
// ═══════════════════════════════════════════════════════════════════════════

// Calculate position size based on risk
stopDistance = atr * stopLossATR
riskAmount = strategy.equity * (riskPercent / 100)
positionSize = riskAmount / stopDistance

// Entry & Exit levels
longSL = close - stopDistance
longTP = close + (stopDistance * takeProfitRR)
shortSL = close + stopDistance
shortTP = close - (stopDistance * takeProfitRR)

// Execute Long
if longCondition and strategy.position_size == 0
    strategy.entry("Long", strategy.long)
    lastTradeBar := bar_index
    dailyTrades += 1

// Execute Short
if shortCondition and strategy.position_size == 0
    strategy.entry("Short", strategy.short)
    lastTradeBar := bar_index
    dailyTrades += 1

// Exit management
if strategy.position_size > 0
    strategy.exit("Long Exit", "Long", stop=longSL, limit=longTP)

    // Trailing stop after activation
    if useTrailingStop
        profitPoints = close - strategy.position_avg_price
        activationLevel = stopDistance * trailActivation
        if profitPoints >= activationLevel
            trailStop = close - (atr * trailOffset)
            strategy.exit("Long Trail", "Long", stop=trailStop)

if strategy.position_size < 0
    strategy.exit("Short Exit", "Short", stop=shortSL, limit=shortTP)

    if useTrailingStop
        profitPoints = strategy.position_avg_price - close
        activationLevel = stopDistance * trailActivation
        if profitPoints >= activationLevel
            trailStop = close + (atr * trailOffset)
            strategy.exit("Short Trail", "Short", stop=trailStop)

// ═══════════════════════════════════════════════════════════════════════════
//                              VISUALS
// ═══════════════════════════════════════════════════════════════════════════

// Entry signals
plotshape(longCondition, title="Long", location=location.belowbar, style=shape.triangleup, size=size.small, color=color.green, text="L")
plotshape(shortCondition, title="Short", location=location.abovebar, style=shape.triangledown, size=size.small, color=color.red, text="S")

// Confluence markers
plotshape(bullishSFP, title="Bull SFP", location=location.belowbar, style=shape.circle, size=size.tiny, color=color.new(color.green, 60))
plotshape(bearishSFP, title="Bear SFP", location=location.abovebar, style=shape.circle, size=size.tiny, color=color.new(color.red, 60))

// Range lines
var line rhL = na, var line rlL = na, var line eqL = na
if barstate.islast
    line.delete(rhL), line.delete(rlL), line.delete(eqL)
    if not na(rangeHigh)
        rhL := line.new(bar_index - 50, rangeHigh, bar_index + 5, rangeHigh, color=color.red, width=2)
    if not na(rangeLow)
        rlL := line.new(bar_index - 50, rangeLow, bar_index + 5, rangeLow, color=color.green, width=2)
    if not na(equilibrium)
        eqL := line.new(bar_index - 50, equilibrium, bar_index + 5, equilibrium, color=color.blue, width=1, style=line.style_dashed)

// Background
bgcolor(inDemandZone ? color.new(color.green, 95) : na)
bgcolor(inSupplyZone ? color.new(color.red, 95) : na)

// ═══════════════════════════════════════════════════════════════════════════
//                              INFO TABLE
// ═══════════════════════════════════════════════════════════════════════════

var table infoTbl = table.new(position=position.top_right, columns=2, rows=8, bgcolor=color.new(color.black, 85), border_width=1, border_color=color.gray)

if barstate.islast
    // Header
    table.cell(infoTbl, 0, 0, "EPA Pro v3", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.blue, 70))
    table.cell(infoTbl, 1, 0, syminfo.ticker, text_color=color.yellow, text_size=size.tiny, bgcolor=color.new(color.blue, 70))

    // HTF Status
    htf1Status = htf1Bullish ? "BULL" : htf1Bearish ? "BEAR" : "NEUT"
    htf1Col = htf1Bullish ? color.green : htf1Bearish ? color.red : color.gray
    table.cell(infoTbl, 0, 1, "HTF Trend", text_color=color.gray, text_size=size.tiny)
    table.cell(infoTbl, 1, 1, htf1Status, text_color=htf1Col, text_size=size.tiny)

    // Confluence
    table.cell(infoTbl, 0, 2, "Long Conf", text_color=color.gray, text_size=size.tiny)
    table.cell(infoTbl, 1, 2, str.tostring(longConfluence) + "/" + str.tostring(minConfluence), text_color=longConfluence >= minConfluence ? color.green : color.gray, text_size=size.tiny)

    table.cell(infoTbl, 0, 3, "Short Conf", text_color=color.gray, text_size=size.tiny)
    table.cell(infoTbl, 1, 3, str.tostring(shortConfluence) + "/" + str.tostring(minConfluence), text_color=shortConfluence >= minConfluence ? color.red : color.gray, text_size=size.tiny)

    // Position
    posText = strategy.position_size > 0 ? "LONG" : strategy.position_size < 0 ? "SHORT" : "FLAT"
    posCol = strategy.position_size > 0 ? color.green : strategy.position_size < 0 ? color.red : color.gray
    table.cell(infoTbl, 0, 4, "Position", text_color=color.gray, text_size=size.tiny)
    table.cell(infoTbl, 1, 4, posText, text_color=posCol, text_size=size.tiny)

    // Stats
    winRate = strategy.closedtrades > 0 ? strategy.wintrades / strategy.closedtrades * 100 : 0
    table.cell(infoTbl, 0, 5, "Win Rate", text_color=color.gray, text_size=size.tiny)
    table.cell(infoTbl, 1, 5, str.tostring(winRate, "#.#") + "%", text_color=winRate >= 40 ? color.green : color.red, text_size=size.tiny)

    table.cell(infoTbl, 0, 6, "Trades", text_color=color.gray, text_size=size.tiny)
    table.cell(infoTbl, 1, 6, str.tostring(strategy.closedtrades), text_color=color.white, text_size=size.tiny)

    profitFactor = strategy.grossloss != 0 ? strategy.grossprofit / math.abs(strategy.grossloss) : 0
    table.cell(infoTbl, 0, 7, "Profit Factor", text_color=color.gray, text_size=size.tiny)
    table.cell(infoTbl, 1, 7, str.tostring(profitFactor, "#.##"), text_color=profitFactor >= 1.5 ? color.green : profitFactor >= 1 ? color.yellow : color.red, text_size=size.tiny)

// ═══════════════════════════════════════════════════════════════════════════
// END OF STRATEGY v3
// ═══════════════════════════════════════════════════════════════════════════
