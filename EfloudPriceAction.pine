// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Efloud Price Action Trading System v2.0 - Optimized Edition
// Based on @EfloudTheSurfer's methodology

//@version=6
indicator("Efloud Price Action System v2", shorttitle="EPA v2", overlay=true, max_boxes_count=100, max_lines_count=100, max_labels_count=100)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//                              INPUT SETTINGS
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
// ══════════════════════════════════════════════════════════════════════════════

// ─────────────────── Performance & Display Mode ───────────────────
grpPerformance = "═══ Performance & Display ═══"
minimalMode = input.bool(false, "Minimal Display Mode", group=grpPerformance, tooltip="Reduces visual clutter for cleaner charts")
minBarsBetweenLabels = input.int(10, "Min Bars Between Signals", minval=1, maxval=50, group=grpPerformance, tooltip="Prevents signal spam")
clusterThreshold = input.float(0.5, "Cluster Filter (%)", minval=0.1, maxval=3.0, step=0.1, group=grpPerformance, tooltip="Ignores signals at similar price levels")
maxLabelAge = input.int(100, "Label Lifetime (Bars)", minval=20, maxval=300, group=grpPerformance, tooltip="Auto-delete old labels")
maxZoneAge = input.int(150, "Zone Lifetime (Bars)", minval=50, maxval=500, group=grpPerformance, tooltip="Auto-delete old zones")

// ─────────────────── Structure Settings ───────────────────
grpStructure = "═══ Range Structure Settings ═══"
pivotLookback = input.int(10, "Pivot Lookback Period", minval=3, maxval=50, group=grpStructure)
pivotLookforward = input.int(10, "Pivot Lookforward Period", minval=3, maxval=50, group=grpStructure)
showRangeLines = input.bool(true, "Show RH/RL/EQ Lines", group=grpStructure)
showZoneBoxes = input.bool(true, "Show Supply/Demand Boxes", group=grpStructure)
zoneExtendBars = input.int(50, "Zone Extension (Bars)", minval=10, maxval=200, group=grpStructure)

// ─────────────────── Zone Settings ───────────────────
grpZones = "═══ Zone Visualization ═══"
demandColor = input.color(color.new(color.green, 85), "Demand Zone Color", group=grpZones)
demandBorderColor = input.color(color.new(color.green, 50), "Demand Zone Border", group=grpZones)
supplyColor = input.color(color.new(color.red, 85), "Supply Zone Color", group=grpZones)
supplyBorderColor = input.color(color.new(color.red, 50), "Supply Zone Border", group=grpZones)
eqBorderColor = input.color(color.new(color.blue, 30), "EQ Line Color", group=grpZones)
zoneWidth = input.int(1, "Zone Border Width", minval=1, maxval=3, group=grpZones)

// ─────────────────── Pattern Detection Settings ───────────────────
grpPatterns = "═══ Pattern Detection ═══"
showSFP = input.bool(true, "Show Swing Failure Patterns (SFP)", group=grpPatterns)
sfpWickRatio = input.float(2.0, "SFP Wick/Body Ratio", minval=1.0, maxval=5.0, step=0.1, group=grpPatterns)
showBreakers = input.bool(true, "Show Breaker Blocks", group=grpPatterns)
showMitigation = input.bool(true, "Show Mitigation Blocks", group=grpPatterns)

// ─────────────────── EQH/EQL Settings ───────────────────
grpEQL = "═══ Equal Highs/Lows (Liquidity) ═══"
showEQHL = input.bool(true, "Show EQH/EQL Levels", group=grpEQL)
eqhlThreshold = input.float(0.1, "EQH/EQL Threshold (%)", minval=0.01, maxval=1.0, step=0.01, group=grpEQL)
eqhlExpireBars = input.int(100, "EQH/EQL Expire After (Bars)", minval=20, maxval=500, group=grpEQL)
eqhColor = input.color(color.new(color.orange, 60), "EQH Color", group=grpEQL)
eqlColor = input.color(color.new(color.teal, 60), "EQL Color", group=grpEQL)

// ─────────────────── MTF Dashboard Settings ───────────────────
grpMTF = "═══ Multi-Timeframe Dashboard ═══"
showDashboard = input.bool(true, "Show MTF Dashboard", group=grpMTF)
compactDashboard = input.bool(true, "Compact Dashboard (5 rows)", group=grpMTF)
dashboardPosition = input.string("Top Right", "Dashboard Position", options=["Top Right", "Top Left", "Bottom Right", "Bottom Left"], group=grpMTF)
htfTimeframe1 = input.timeframe("D", "HTF 1 (Trend)", group=grpMTF)
htfTimeframe2 = input.timeframe("240", "HTF 2 (Structure)", group=grpMTF)

// ─────────────────── Indicator Settings (Optional) ───────────────────
grpIndicators = "═══ Optional Indicators ═══"
showRSI = input.bool(false, "Show RSI Status", group=grpIndicators)
rsiLength = input.int(14, "RSI Length", minval=5, maxval=50, group=grpIndicators)
showOBV = input.bool(false, "Show OBV Trend", group=grpIndicators)
obvLength = input.int(9, "OBV MA Length", minval=3, maxval=30, group=grpIndicators)
showDMA = input.bool(false, "Show DMA (50 EMA)", group=grpIndicators)
dmaLength = input.int(50, "DMA Length", minval=10, maxval=200, group=grpIndicators)

// ─────────────────── Visual Settings ───────────────────
grpVisual = "═══ Visual Settings ═══"
labelSize = input.string("tiny", "Label Size", options=["tiny", "small", "normal"], group=grpVisual)
showLabels = input.bool(true, "Show Pattern Labels", group=grpVisual)
showRiskReward = input.bool(false, "Show Risk/Reward Info", group=grpVisual)
minRiskReward = input.float(2.0, "Minimum R:R Ratio", minval=1.0, maxval=10.0, step=0.5, group=grpVisual)

// ═══════════════════════════════════════════════════════════════════════════
//                         PERFORMANCE VARIABLES
// ═══════════════════════════════════════════════════════════════════════════

// Signal filtering state
var int lastSFPBar = -10000
var int lastBreakerBar = -10000
var int lastMitigationBar = -10000
var int lastZoneBar = -10000
var float lastSignalPrice = 0.0

// Label management arrays
var label[] managedLabels = array.new_label()
var int[] labelBars = array.new_int()

// Apply minimal mode overrides
var bool effectiveShowLabels = showLabels
var bool effectiveShowBreakers = showBreakers
var bool effectiveShowMitigation = showMitigation
var bool effectiveShowEQHL = showEQHL

if minimalMode
    effectiveShowLabels := false
    effectiveShowBreakers := false
    effectiveShowMitigation := false

// ═══════════════════════════════════════════════════════════════════════════
//                            HELPER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════

getLabelSize(sizeStr) =>
    switch sizeStr
        "tiny" => size.tiny
        "small" => size.small
        "normal" => size.normal
        => size.tiny

getDashboardPosition(posStr) =>
    switch posStr
        "Top Right" => position.top_right
        "Top Left" => position.top_left
        "Bottom Right" => position.bottom_right
        "Bottom Left" => position.bottom_left
        => position.top_right

// Cluster filter check
canPlotSignal(signalPrice, lastBar) =>
    barFilter = bar_index - lastBar >= minBarsBetweenLabels
    priceFilter = math.abs(close - lastSignalPrice) > close * clusterThreshold / 100
    barFilter and priceFilter

// Managed label creation with auto-cleanup
createManagedLabel(x, y, txt, style, bgColor, txtColor) =>
    if effectiveShowLabels
        newLabel = label.new(x, y, txt, style=style, color=bgColor, textcolor=txtColor, size=getLabelSize(labelSize))
        array.push(managedLabels, newLabel)
        array.push(labelBars, bar_index)

// ═══════════════════════════════════════════════════════════════════════════
//                         AUTO-CLEANUP SYSTEM
// ═══════════════════════════════════════════════════════════════════════════

// Clean up old labels
if array.size(managedLabels) > 0
    for i = array.size(managedLabels) - 1 to 0
        if i < array.size(labelBars) and i < array.size(managedLabels)
            if bar_index - array.get(labelBars, i) > maxLabelAge
                label.delete(array.get(managedLabels, i))
                array.remove(managedLabels, i)
                array.remove(labelBars, i)

// Limit label array size
if array.size(managedLabels) > 50
    label.delete(array.get(managedLabels, 0))
    array.shift(managedLabels)
    array.shift(labelBars)

// ═══════════════════════════════════════════════════════════════════════════
//                          BASIC CALCULATIONS
// ═══════════════════════════════════════════════════════════════════════════

bodySize = math.abs(close - open)
upperWick = high - math.max(close, open)
lowerWick = math.min(close, open) - low
isBullish = close > open
isBearish = close < open
atr = ta.atr(14)

// Pivot Detection
pivotHigh = ta.pivothigh(high, pivotLookback, pivotLookforward)
pivotLow = ta.pivotlow(low, pivotLookback, pivotLookforward)

// ═══════════════════════════════════════════════════════════════════════════
//                         RANGE STRUCTURE ENGINE
// ═══════════════════════════════════════════════════════════════════════════

var float rangeHigh = na
var float rangeLow = na
var float equilibrium = na

if not na(pivotHigh)
    rangeHigh := pivotHigh

if not na(pivotLow)
    rangeLow := pivotLow

if not na(rangeHigh) and not na(rangeLow)
    equilibrium := (rangeHigh + rangeLow) / 2

// Draw Range Lines (only on last bar)
var line rhLine = na
var line rlLine = na
var line eqLine = na
var label rhLabel = na
var label rlLabel = na
var label eqLabel = na

if showRangeLines and barstate.islast
    line.delete(rhLine)
    line.delete(rlLine)
    line.delete(eqLine)
    label.delete(rhLabel)
    label.delete(rlLabel)
    label.delete(eqLabel)

    if not na(rangeHigh)
        rhLine := line.new(bar_index - 50, rangeHigh, bar_index + 5, rangeHigh, color=supplyBorderColor, width=2, style=line.style_solid)
        rhLabel := label.new(bar_index + 7, rangeHigh, "RH", style=label.style_label_left, color=color.new(color.red, 90), textcolor=color.red, size=size.tiny)

    if not na(rangeLow)
        rlLine := line.new(bar_index - 50, rangeLow, bar_index + 5, rangeLow, color=demandBorderColor, width=2, style=line.style_solid)
        rlLabel := label.new(bar_index + 7, rangeLow, "RL", style=label.style_label_left, color=color.new(color.green, 90), textcolor=color.green, size=size.tiny)

    if not na(equilibrium)
        eqLine := line.new(bar_index - 50, equilibrium, bar_index + 5, equilibrium, color=eqBorderColor, width=1, style=line.style_dashed)
        eqLabel := label.new(bar_index + 7, equilibrium, "EQ", style=label.style_label_left, color=color.new(color.blue, 90), textcolor=color.blue, size=size.tiny)

// ═══════════════════════════════════════════════════════════════════════════
//                        SUPPLY/DEMAND ZONES (Optimized)
// ═══════════════════════════════════════════════════════════════════════════

var box[] demandBoxes = array.new_box()
var float[] demandTops = array.new_float()
var float[] demandBottoms = array.new_float()
var int[] demandBars = array.new_int()

var box[] supplyBoxes = array.new_box()
var float[] supplyTops = array.new_float()
var float[] supplyBottoms = array.new_float()
var int[] supplyBars = array.new_int()

// Zone conditions with frequency filter
demandZoneCondition = (isBullish and close > high[1] and bodySize > atr * 0.5 and close[1] < open[1])
supplyZoneCondition = (isBearish and close < low[1] and bodySize > atr * 0.5 and close[1] > open[1])

canCreateZone = bar_index - lastZoneBar >= minBarsBetweenLabels

// Create Demand Zones (filtered)
if showZoneBoxes and demandZoneCondition and canCreateZone
    zoneTop = math.max(high[1], open[1])
    zoneBottom = low[1]

    newBox = box.new(bar_index - 1, zoneTop, bar_index + zoneExtendBars, zoneBottom, bgcolor=demandColor, border_color=demandBorderColor, border_width=zoneWidth)
    array.push(demandBoxes, newBox)
    array.push(demandTops, zoneTop)
    array.push(demandBottoms, zoneBottom)
    array.push(demandBars, bar_index)
    lastZoneBar := bar_index

// Create Supply Zones (filtered)
if showZoneBoxes and supplyZoneCondition and canCreateZone
    zoneTop = high[1]
    zoneBottom = math.min(low[1], open[1])

    newBox = box.new(bar_index - 1, zoneTop, bar_index + zoneExtendBars, zoneBottom, bgcolor=supplyColor, border_color=supplyBorderColor, border_width=zoneWidth)
    array.push(supplyBoxes, newBox)
    array.push(supplyTops, zoneTop)
    array.push(supplyBottoms, zoneBottom)
    array.push(supplyBars, bar_index)
    lastZoneBar := bar_index

// Zone invalidation + age cleanup
if array.size(demandBoxes) > 0
    for i = array.size(demandBoxes) - 1 to 0
        if i < array.size(demandBottoms) and i < array.size(demandBars)
            isInvalidated = close < array.get(demandBottoms, i)
            isExpired = bar_index - array.get(demandBars, i) > maxZoneAge
            if isInvalidated or isExpired
                box.delete(array.get(demandBoxes, i))
                array.remove(demandBoxes, i)
                array.remove(demandTops, i)
                array.remove(demandBottoms, i)
                array.remove(demandBars, i)

if array.size(supplyBoxes) > 0
    for i = array.size(supplyBoxes) - 1 to 0
        if i < array.size(supplyTops) and i < array.size(supplyBars)
            isInvalidated = close > array.get(supplyTops, i)
            isExpired = bar_index - array.get(supplyBars, i) > maxZoneAge
            if isInvalidated or isExpired
                box.delete(array.get(supplyBoxes, i))
                array.remove(supplyBoxes, i)
                array.remove(supplyTops, i)
                array.remove(supplyBottoms, i)
                array.remove(supplyBars, i)

// Limit zone arrays
if array.size(demandBoxes) > 15
    box.delete(array.get(demandBoxes, 0))
    array.shift(demandBoxes)
    array.shift(demandTops)
    array.shift(demandBottoms)
    array.shift(demandBars)

if array.size(supplyBoxes) > 15
    box.delete(array.get(supplyBoxes, 0))
    array.shift(supplyBoxes)
    array.shift(supplyTops)
    array.shift(supplyBottoms)
    array.shift(supplyBars)

// ═══════════════════════════════════════════════════════════════════════════
//                    SFP DETECTION (Optimized)
// ═══════════════════════════════════════════════════════════════════════════

recentSwingHigh = ta.highest(high, 20)[1]
recentSwingLow = ta.lowest(low, 20)[1]

bearishSFP = (showSFP and high > recentSwingHigh and close < recentSwingHigh and close < open and upperWick > bodySize * sfpWickRatio)
bullishSFP = (showSFP and low < recentSwingLow and close > recentSwingLow and close > open and lowerWick > bodySize * sfpWickRatio)

// Filtered SFP signals
canPlotSFP = canPlotSignal(close, lastSFPBar)

if bearishSFP and canPlotSFP
    createManagedLabel(bar_index, high, "SFP", label.style_label_down, color.new(color.red, 30), color.white)
    lastSFPBar := bar_index
    lastSignalPrice := close

if bullishSFP and canPlotSFP
    createManagedLabel(bar_index, low, "SFP", label.style_label_up, color.new(color.green, 30), color.white)
    lastSFPBar := bar_index
    lastSignalPrice := close

// Simple shape markers (always show, lightweight)
plotshape(bearishSFP and canPlotSFP, title="Bearish SFP", location=location.abovebar, style=shape.triangledown, size=size.tiny, color=color.red)
plotshape(bullishSFP and canPlotSFP, title="Bullish SFP", location=location.belowbar, style=shape.triangleup, size=size.tiny, color=color.green)

// ═══════════════════════════════════════════════════════════════════════════
//                    BREAKER BLOCK DETECTION (Optimized)
// ═══════════════════════════════════════════════════════════════════════════

var float[] obHighs = array.new_float()
var float[] obLows = array.new_float()
var int[] obBars = array.new_int()
var bool[] obBullish = array.new_bool()

bullishOB = isBullish and bodySize > atr * 0.8 and close > high[1]
bearishOB = isBearish and bodySize > atr * 0.8 and close < low[1]

if effectiveShowBreakers and bullishOB and bar_index - lastBreakerBar >= 5
    array.push(obHighs, high)
    array.push(obLows, low[1])
    array.push(obBars, bar_index)
    array.push(obBullish, true)

if effectiveShowBreakers and bearishOB and bar_index - lastBreakerBar >= 5
    array.push(obHighs, high[1])
    array.push(obLows, low)
    array.push(obBars, bar_index)
    array.push(obBullish, false)

canPlotBreaker = canPlotSignal(close, lastBreakerBar)

if effectiveShowBreakers and array.size(obHighs) > 0
    for i = array.size(obHighs) - 1 to 0
        if i < array.size(obHighs)
            obHigh = array.get(obHighs, i)
            obLow = array.get(obLows, i)
            obBar = array.get(obBars, i)
            wasBullish = array.get(obBullish, i)

            if wasBullish and close[1] < obLow and high >= obLow and high <= obHigh and canPlotBreaker
                createManagedLabel(bar_index, high, "BRK", label.style_label_down, color.new(color.purple, 30), color.white)
                lastBreakerBar := bar_index
                lastSignalPrice := close
                array.remove(obHighs, i)
                array.remove(obLows, i)
                array.remove(obBars, i)
                array.remove(obBullish, i)
            else if not wasBullish and close[1] > obHigh and low <= obHigh and low >= obLow and canPlotBreaker
                createManagedLabel(bar_index, low, "BRK", label.style_label_up, color.new(color.teal, 30), color.white)
                lastBreakerBar := bar_index
                lastSignalPrice := close
                array.remove(obHighs, i)
                array.remove(obLows, i)
                array.remove(obBars, i)
                array.remove(obBullish, i)
            else if bar_index - obBar > 150
                array.remove(obHighs, i)
                array.remove(obLows, i)
                array.remove(obBars, i)
                array.remove(obBullish, i)

if array.size(obHighs) > 30
    array.shift(obHighs)
    array.shift(obLows)
    array.shift(obBars)
    array.shift(obBullish)

// ═══════════════════════════════════════════════════════════════════════════
//                    MITIGATION BLOCK (Optimized)
// ═══════════════════════════════════════════════════════════════════════════

var float lastSwingHigh = na
var float lastSwingLow = na

if not na(pivotHigh)
    lastSwingHigh := pivotHigh

if not na(pivotLow)
    lastSwingLow := pivotLow

bearishMitigation = (effectiveShowMitigation and not na(lastSwingHigh) and high[2] > lastSwingHigh and close[2] < lastSwingHigh and close[1] < close[2] and close < close[1])
bullishMitigation = (effectiveShowMitigation and not na(lastSwingLow) and low[2] < lastSwingLow and close[2] > lastSwingLow and close[1] > close[2] and close > close[1])

canPlotMit = canPlotSignal(close, lastMitigationBar)

if bearishMitigation and canPlotMit
    createManagedLabel(bar_index - 2, high[2], "MIT", label.style_label_down, color.new(color.maroon, 30), color.white)
    lastMitigationBar := bar_index
    lastSignalPrice := close

if bullishMitigation and canPlotMit
    createManagedLabel(bar_index - 2, low[2], "MIT", label.style_label_up, color.new(color.lime, 30), color.white)
    lastMitigationBar := bar_index
    lastSignalPrice := close

// ═══════════════════════════════════════════════════════════════════════════
//                    EQH/EQL LIQUIDITY (Optimized)
// ═══════════════════════════════════════════════════════════════════════════

var float[] eqhLevels = array.new_float()
var int[] eqhBars = array.new_int()
var float[] eqlLevels = array.new_float()
var int[] eqlBars = array.new_int()

eqhlThresholdValue = close * (eqhlThreshold / 100)

eqhDetected = (effectiveShowEQHL and not na(pivotHigh) and array.size(eqhLevels) > 0 and math.abs(pivotHigh - array.get(eqhLevels, array.size(eqhLevels) - 1)) < eqhlThresholdValue)
newEQH = (effectiveShowEQHL and not na(pivotHigh) and not eqhDetected)

eqlDetected = (effectiveShowEQHL and not na(pivotLow) and array.size(eqlLevels) > 0 and math.abs(pivotLow - array.get(eqlLevels, array.size(eqlLevels) - 1)) < eqhlThresholdValue)
newEQL = (effectiveShowEQHL and not na(pivotLow) and not eqlDetected)

if eqhDetected
    avgLevel = (pivotHigh + array.get(eqhLevels, array.size(eqhLevels) - 1)) / 2
    line.new(array.get(eqhBars, array.size(eqhBars) - 1), avgLevel, bar_index + 15, avgLevel, color=eqhColor, width=1, style=line.style_dotted)

if newEQH
    array.push(eqhLevels, pivotHigh)
    array.push(eqhBars, bar_index - pivotLookforward)

if eqlDetected
    avgLevel = (pivotLow + array.get(eqlLevels, array.size(eqlLevels) - 1)) / 2
    line.new(array.get(eqlBars, array.size(eqlBars) - 1), avgLevel, bar_index + 15, avgLevel, color=eqlColor, width=1, style=line.style_dotted)

if newEQL
    array.push(eqlLevels, pivotLow)
    array.push(eqlBars, bar_index - pivotLookforward)

// Cleanup expired
if array.size(eqhBars) > 0
    for i = array.size(eqhBars) - 1 to 0
        if bar_index - array.get(eqhBars, i) > eqhlExpireBars
            array.remove(eqhLevels, i)
            array.remove(eqhBars, i)

if array.size(eqlBars) > 0
    for i = array.size(eqlBars) - 1 to 0
        if bar_index - array.get(eqlBars, i) > eqhlExpireBars
            array.remove(eqlLevels, i)
            array.remove(eqlBars, i)

if array.size(eqhLevels) > 10
    array.shift(eqhLevels)
    array.shift(eqhBars)

if array.size(eqlLevels) > 10
    array.shift(eqlLevels)
    array.shift(eqlBars)

// ═══════════════════════════════════════════════════════════════════════════
//                    MTF DASHBOARD (Optimized)
// ═══════════════════════════════════════════════════════════════════════════

// MTF requests with tuple unpacking
[htf1Close, htf1EMA] = request.security(syminfo.tickerid, htfTimeframe1, [close, ta.ema(close, dmaLength)], lookahead=barmerge.lookahead_off)
[htf2Close, htf2EMA] = request.security(syminfo.tickerid, htfTimeframe2, [close, ta.ema(close, 20)], lookahead=barmerge.lookahead_off)

htf1Bias = htf1Close > htf1EMA ? "BULL" : "BEAR"
htf2Bias = htf2Close > htf2EMA ? "BULL" : "BEAR"
htf1Color = htf1Close > htf1EMA ? color.green : color.red
htf2Color = htf2Close > htf2EMA ? color.green : color.red

// RSI/OBV (only if enabled)
htfRSI = showRSI ? request.security(syminfo.tickerid, htfTimeframe1, ta.rsi(close, rsiLength)) : 0.0
obv = ta.obv
obvMA = ta.sma(obv, obvLength)
obvTrend = obv > obvMA ? "BULL" : "BEAR"
obvColor = obv > obvMA ? color.green : color.red

// Compact dashboard
dashRows = compactDashboard ? 5 : 7
var table dashboard = table.new(position=getDashboardPosition(dashboardPosition), columns=2, rows=dashRows, bgcolor=color.new(color.black, 85), border_width=1, border_color=color.gray)

if showDashboard and barstate.islast
    table.cell(dashboard, 0, 0, "EPA v2", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.blue, 70))
    table.cell(dashboard, 1, 0, syminfo.ticker, text_color=color.yellow, text_size=size.tiny, bgcolor=color.new(color.blue, 70))

    table.cell(dashboard, 0, 1, htfTimeframe1, text_color=color.gray, text_size=size.tiny)
    table.cell(dashboard, 1, 1, htf1Bias, text_color=htf1Color, text_size=size.tiny)

    table.cell(dashboard, 0, 2, htfTimeframe2, text_color=color.gray, text_size=size.tiny)
    table.cell(dashboard, 1, 2, htf2Bias, text_color=htf2Color, text_size=size.tiny)

    table.cell(dashboard, 0, 3, "RH/EQ/RL", text_color=color.gray, text_size=size.tiny)
    table.cell(dashboard, 1, 3, str.tostring(rangeHigh, "#.##") + "/" + str.tostring(equilibrium, "#.##") + "/" + str.tostring(rangeLow, "#.##"), text_color=color.white, text_size=size.tiny)

    if compactDashboard
        rsiText = showRSI ? str.tostring(htfRSI, "#") : "-"
        obvText = showOBV ? obvTrend : "-"
        table.cell(dashboard, 0, 4, "RSI/OBV", text_color=color.gray, text_size=size.tiny)
        table.cell(dashboard, 1, 4, rsiText + " / " + obvText, text_color=color.white, text_size=size.tiny)
    else
        if showRSI
            table.cell(dashboard, 0, 4, "RSI", text_color=color.gray, text_size=size.tiny)
            table.cell(dashboard, 1, 4, str.tostring(htfRSI, "#.#"), text_color=htfRSI > 50 ? color.green : color.red, text_size=size.tiny)
        if showOBV
            table.cell(dashboard, 0, 5, "OBV", text_color=color.gray, text_size=size.tiny)
            table.cell(dashboard, 1, 5, obvTrend, text_color=obvColor, text_size=size.tiny)

// ═══════════════════════════════════════════════════════════════════════════
//                         ZONE ENTRY DETECTION
// ═══════════════════════════════════════════════════════════════════════════

inDemandZone = false
if array.size(demandBoxes) > 0
    for i = 0 to array.size(demandBoxes) - 1
        if i < array.size(demandTops) and i < array.size(demandBottoms)
            if low <= array.get(demandTops, i) and high >= array.get(demandBottoms, i)
                inDemandZone := true

inSupplyZone = false
if array.size(supplyBoxes) > 0
    for i = 0 to array.size(supplyBoxes) - 1
        if i < array.size(supplyTops) and i < array.size(supplyBottoms)
            if high >= array.get(supplyBottoms, i) and low <= array.get(supplyTops, i)
                inSupplyZone := true

eqBreakBullish = not na(equilibrium) and close > equilibrium and close[1] <= equilibrium
eqBreakBearish = not na(equilibrium) and close < equilibrium and close[1] >= equilibrium

// Subtle background (very light)
bgcolor(inDemandZone ? color.new(color.green, 97) : na, title="Demand Zone")
bgcolor(inSupplyZone ? color.new(color.red, 97) : na, title="Supply Zone")

// ═══════════════════════════════════════════════════════════════════════════
//                           DMA PLOT
// ═══════════════════════════════════════════════════════════════════════════

dma = ta.ema(close, dmaLength)
plot(showDMA ? dma : na, title="DMA", color=color.new(color.yellow, 40), linewidth=1)

// ═══════════════════════════════════════════════════════════════════════════
//                         CONFLUENCE SIGNALS
// ═══════════════════════════════════════════════════════════════════════════

htfBullish = htf1Close > htf1EMA
htfBearish = htf1Close < htf1EMA

longSignal = inDemandZone and htfBullish and (bullishSFP or bullishMitigation)
shortSignal = inSupplyZone and htfBearish and (bearishSFP or bearishMitigation)

plotshape(longSignal and not longSignal[1], title="Long Signal", location=location.belowbar, style=shape.labelup, size=size.small, color=color.green, text="L", textcolor=color.white)
plotshape(shortSignal and not shortSignal[1], title="Short Signal", location=location.abovebar, style=shape.labeldown, size=size.small, color=color.red, text="S", textcolor=color.white)

// ═══════════════════════════════════════════════════════════════════════════
//                           ALERT CONDITIONS
// ═══════════════════════════════════════════════════════════════════════════

alertcondition(inDemandZone and not inDemandZone[1], title="Demand Zone Entry", message="{{ticker}}: Price entered demand zone")
alertcondition(inSupplyZone and not inSupplyZone[1], title="Supply Zone Entry", message="{{ticker}}: Price entered supply zone")
alertcondition(bullishSFP and canPlotSFP, title="Bullish SFP", message="{{ticker}}: Bullish SFP detected")
alertcondition(bearishSFP and canPlotSFP, title="Bearish SFP", message="{{ticker}}: Bearish SFP detected")
alertcondition(eqBreakBullish, title="Bullish EQ Break", message="{{ticker}}: Price broke above EQ")
alertcondition(eqBreakBearish, title="Bearish EQ Break", message="{{ticker}}: Price broke below EQ")
alertcondition(longSignal and not longSignal[1], title="Long Confluence", message="{{ticker}}: LONG signal - demand zone + HTF bullish + confirmation")
alertcondition(shortSignal and not shortSignal[1], title="Short Confluence", message="{{ticker}}: SHORT signal - supply zone + HTF bearish + confirmation")

// ═══════════════════════════════════════════════════════════════════════════
// END OF SCRIPT - EPA v2.0 Optimized
// ═══════════════════════════════════════════════════════════════════════════
